## 原型模式
原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的
实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身
的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。
原型模式有两种表现形式：（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。
## 简单形式的原型模式
> (1)客户()Client)角色：客户类提出创建对象的请求。<br>
> (2)抽象原型()Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出
所有的具体原型类所需的接口。<br>
> (3)具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。<br>

![简单形式的原型模式](https://github.com/lzh984294471/designPattern/raw/master/pics/simplePrototype.png)

## 登记形式的原型模式
作为原型模式的第二种形式，它多了一个原型管理器()PrototypeManager)角色，该角色的作用是：创建具体
原型类的对象，并记录每一个被创建的对象。 <br>
![登记形式的原型模式](https://github.com/lzh984294471/designPattern/raw/master/pics/prototype.png)
## 两种形式的比较
简单形式和登记形式的原型模式各有其长处和短处。
如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的
引用可以由客户端自己保存。如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况
下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可
以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；
如果没有，客户端就需要自行复制此原型对象。
